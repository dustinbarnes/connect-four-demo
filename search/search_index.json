{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Connect Four Demo Project","text":"<p>I need/want a project that can highlight some of my skills and expertise. Since most of my work is non-public, it can be a struggle to find that sweet spot of having enough complexity, but not too much. </p> <p>After some deliberation, I figured a web-based connect-four style game can do this. I can highlight the primary components of building a service that can scale -- a Java/Spring Boot backend, a Vite/React frontend, a Playwright e2e test suite, and an API-first approach. The build and structure of this application is mildly obtuse so that it mimics some of the real-world pains of projects at scale. </p> <p>This site is generated via a GitHub Action. If you are reading this on GitHub.com, you can visit the generated site here: https//dustinbarnes.github.io/connect-four-demo/</p>"},{"location":"00-inception/","title":"Inception","text":"<p>Connect Four? Let's go! </p>"},{"location":"00-inception/#api-first","title":"API First","text":"<p>This is an approach I've long espoused, so let's put our money where our mouth is. We want to start with an API definition, use those definitions to generate code, then tie that code together with our logic. </p> <p>We will define our HTTP endpoints, core DTOs, and message objects with an OpenAPI spec. We'll spend a good amount of time iterating on this spec before putting down too much code. </p>"},{"location":"00-inception/#future-plans","title":"Future Plans","text":"<p>The point of this project is to highlight work efforts, so I expect that some major things will change. The only real plan is to follow this effort where it takes me, and to document the process along the way.</p>"},{"location":"01-bookkeeping/","title":"Bookkeeping","text":"<p>The point of this project is to highight a project, but also to tell a story. Software systems rarely exist in a vacuum, and a lot of the work in learning a new system is understanding how it came to be. </p> <p>The blog posts are meant as milestone markers. For each task I do, I intend to write a new post to explain what I did and why. </p> <p>In order to keep the storytelling going, I'm going to want to be able to show people various states of the project at these important milestones. I've decided that I'll only push a new blog file when I'm ready to share the work.</p>"},{"location":"01-bookkeeping/#automating-with-github-actions","title":"Automating with GitHub Actions","text":"<p>We will be utilizing GitHub actions for our CI/CD tooling -- at least to start. </p> <p>Each time we push a new file in the blog/ directory, I want to tag the repository with the name of the file. </p> <p>This is a relatively straightforward GitHub Action. To that end, I have created this action. </p> <p>Committing this file will be the first test. </p> <p>In true development fashion, the first test failed. The action did not have permissions to write the tags back to the repository. I've updated those permissions, and now the tags are working well. </p>"},{"location":"02-authentication-api/","title":"Authentication API","text":"<p>We're going to start with Authentication. To keep the scope minimal for now, we're going to allow these flows: </p> <ol> <li>Users can register with a username and password<ol> <li>Validate that the username is available</li> </ol> </li> <li>The frontend will send a username/password object (LoginRequest) to the backend. <ol> <li>The backend will grant a JWT token if authentication is successful</li> <li>The frontend will present that JWT for subsequent requests to the backend</li> </ol> </li> </ol> <p>We're going to start API-first and model this as an OpenAPI spec. You'll find that work at ../openapi/auth.yaml. </p> <p>Straightforward username/password registration, and standard HTTP response codes for standard login scenarios.</p>"},{"location":"03-yak-shaving/","title":"Yak Shaving","text":"<p>I refer you to this YouTube video, which features a clip from the TV show Malcolm in the Middle. In it, Hal has to change a light bulb but he keeps running into other things he has to do first, to the point that he's working on his car engine to replace the light bulb. </p> <p>I've also heard it more directly as: </p> <p>[MIT AI Lab, after 2000: orig. probably from a Ren &amp; Stimpy episode.] Any seemingly pointless activity which is actually necessary to solve a problem which solves a problem which, several levels of recursion later, solves the real problem you're working on.</p> <p>If I went from our current state to our next state, which is generated API stubs that pair with our implementation code, you'd find me making decisions about Maven vs Gradle, persistence layers, other things that feel unrelated to implementing an API, but are the annoying necessary things that need to be in place. </p>"},{"location":"03-yak-shaving/#project-basics","title":"Project Basics","text":"<p>The first choices cover the basics, and may or may not be set for you at your organization. Since this is greenfield project, we'll go with the newest stuff:</p> <ul> <li>Java 21</li> <li>Spring Boot 3<ul> <li>Generate controller from OpenAPI spec</li> <li>with Spring Web</li> <li>with Spring Security</li> </ul> </li> <li>Gradle w/ Kotlin (see below)</li> </ul> <p>At this point, in your organization, you may have project starter templates to help with generating new projects. I do not, so I used Spring Initializr which allows you to create a project very quickly. The generated project was extracted to the 'backend/' directory. </p>"},{"location":"03-yak-shaving/#gradle-vs-maven","title":"Gradle vs Maven","text":"<p>I have long espoused the benefits of Maven, where I generally think builds should be declarative instead of imperative, it should be hard to do bad things, and the \"boringness\" of Maven translates to the tooling being extremely capable and mature. I worried that the freedom of Gradle will create more unique snowflake builds, that too much custom logic will seep into the builds, that undisciplined developers wouldn't take the time to understand the tooling, but instead hack in solutions, all leading to an eventual problem when builds are no longer idempotent.</p> <p>However, I haven't given Gradle a genuine shot in several years. Many, many smart people have migrated. It's hard to argue with the skill, scope, or scale of things like Android and Spring Boot. Therefore, I want to challenge myself and give this a genuine shot.</p>"},{"location":"03-yak-shaving/#persistence","title":"Persistence","text":"<p>In order to keep persistance light at this point, we're going with the venerable SQLite. A very capable, extraordinarily stable SQL server that operates from a single file. It's not a database for scaling out to \"web scale\", but it's very quick and uses minimal resources. Its fitness for purpose for a small project like this? Perfect. </p> <p>We still want to practice API first, and I think the tool 'atlas' is a solid fit here. It allows you to define your SQL schema as code, and then it will create migration files for you that you can check in and execute. </p> <p>I've created a minimal Users table, and you can run <code>npm run build</code> in the terminal to perform the schema application. From here on out, you just modify the <code>schema.hcl</code> file, and atlas will take care of migrations. </p> <p>The first migration looks like this: </p> <pre><code>&gt; database@1.0.0 build\n&gt; atlas schema apply --url \"sqlite://dev.db\" --to file://schema.hcl\n\nPlanning migration statements (2 in total):\n\n  -- create \"users\" table:\n    -&gt; CREATE TABLE `users` (\n         `id` integer NOT NULL PRIMARY KEY AUTOINCREMENT,\n         `username` text NOT NULL,\n         `password_hash` text NOT NULL,\n         `created_at` datetime NOT NULL DEFAULT (CURRENT_TIMESTAMP)\n       );\n  -- create index \"username_unique\" to table: \"users\":\n    -&gt; CREATE UNIQUE INDEX `username_unique` ON `users` (`username`);\n\n-------------------------------------------\n\nApplying approved migration (2 statements in total):\n\n  -- create \"users\" table\n    -&gt; CREATE TABLE `users` (\n         `id` integer NOT NULL PRIMARY KEY AUTOINCREMENT,\n         `username` text NOT NULL,\n         `password_hash` text NOT NULL,\n         `created_at` datetime NOT NULL DEFAULT (CURRENT_TIMESTAMP)\n       );\n  -- ok (1.033125ms)\n\n  -- create index \"username_unique\" to table: \"users\"\n    -&gt; CREATE UNIQUE INDEX `username_unique` ON `users` (`username`);\n  -- ok (59.375\u00b5s)\n\n  -------------------------\n  -- 1.146458ms\n  -- 1 migration\n  -- 2 sql statements\n</code></pre> <p>You'll find this work in the ../database directory. </p>"},{"location":"04-authentication-backend/","title":"Authentication Backend","text":"<p>Now we're going to build the backend authentication endpoints. Let's get to it! </p>"},{"location":"04-authentication-backend/#hooking-up-the-database","title":"Hooking Up the Database","text":"<p>SQLite plays very well with Java. I generally don't find ORMs to be very useful, especially for small projects like this. When you have a large object graph that must be sync'd, then sure, pick up Hibernate or whatever. </p> <p>We also aren't going to go raw JDBC. We'll go with one of my favorite project: jOOQ. With a couple of dependencies: </p> <pre><code>    implementation(\"org.jooq:jooq:3.19.7\")\n    implementation(\"org.xerial:sqlite-jdbc:3.45.3.0\")\n</code></pre> <p>And a quick addition to our application.yml file: </p> <pre><code>spring:\n  datasource:\n    url: jdbc:sqlite:../../database/dev.db\n    driver-class-name: org.sqlite.JDBC\n</code></pre> <p>and that's all we really need to get started. We could create a trivial test, but trivial tests are trivial.</p>"},{"location":"04-authentication-backend/#generating-from-the-api","title":"Generating from the API","text":"<p>Let's start with defining our Auth tests. Doing this immediately is why I allowed myself to say that creating a trivial test isn't worth doing at this point. </p> <p>We have our API definition from before, we can use that definition to auto-generate Java classes. The magic is that we only generate API interfaces, and implement those interfaces. In addition, if anything significantly changes in our controller or spec, the build should fail. It forces us to (at least nominally) adhere to our contract. Using Gradle this turned out to be relatively easy: </p> <pre><code>openApiGenerate {\n    generatorName.set(\"spring\")\n    inputSpec.set(\"${rootDir}/../openapi/auth.yaml\")\n    outputDir.set(layout.buildDirectory.dir(\"generated/openapi\").get().asFile.absolutePath)\n    apiPackage.set(\"com.github.dustinbarnes.connect_four_demo.backend.api\")\n    modelPackage.set(\"com.github.dustinbarnes.connect_four_demo.backend.model\")\n    invokerPackage.set(\"com.github.dustinbarnes.connect_four_demo.backend.invoker\")\n    configOptions.set(mapOf(\n        \"interfaceOnly\" to \"true\",\n        \"useTags\" to \"true\",\n        \"dateLibrary\" to \"java8\",\n        \"useSpringBoot3\" to \"true\",\n        \"generateSpringSecurity\" to \"true\",\n    ))\n}\nsourceSets[\"main\"].java.srcDir(layout.buildDirectory.dir(\"generated/openapi/src/main/java\"))\n</code></pre> <p>We tell the generator to generate the code to <code>build/generated/openapi</code> (the <code>src/main/java</code> is automatically added), then tell Gradle that our main source sets includes that directory as well. From here, we can add a minimal AuthController: </p> <pre><code>package com.github.dustinbarnes.connect_four_demo.backend.controller;\n\nimport org.springframework.web.bind.annotation.RestController;\n\npublic class AuthController implements AuthApi{\n\n}\n</code></pre> <p>That's it. The OpenAPI generator creates default interface methods that fail. From here, we can have copilot generate test stubs. It did a pretty good job: </p> <pre><code>    @Test\n    void registerUser_success() throws Exception {\n        AuthRequest request = new AuthRequest();\n        request.setUsername(\"testuser\");\n        request.setPassword(\"testpass\");\n        mockMvc.perform(post(\"/auth/register\")\n                .contentType(MediaType.APPLICATION_JSON)\n                .content(objectMapper.writeValueAsString(request)))\n                .andExpect(status().isCreated());\n    }\n</code></pre> <p>However, some of the other scenarios (like bad inputs) can't be tested because we haven't actually defined valid inputs! </p> <p>I'm going to wrap up this section with this minimal implementation. For next time, we'll have a failing test and we can red-green our way to a solid implementation! </p>"},{"location":"05-authentication-service/","title":"Authentication Service","text":"<p>We've got our stubs, we've got our failing tests. Now it's time to make those tests pass! We're going to need a few things:</p> <p>Things we accomplished: </p> <ul> <li>Integrated JJWT to create signed JWTs</li> <li>Created a UserEntity<ul> <li>Database mapper with UserMapper</li> </ul> </li> <li>Created UserRepository to work with the user data store</li> <li>Created UserService to coordinate the higher-level interactions</li> </ul>"},{"location":"06-yak-shaving-redux/","title":"Yak Shaving Redux","text":"<p>Our next step in building this slice of authentication functionality is to have our frontend use it. That presents a challenge, as we don't actually have a frontend yet. Instead of starting from scratch, let's take advantage of some of the wonderful design work that others have released. Some basic parameters: </p> <ul> <li>NPM+Vite+React<ul> <li>NPM since we're still small -- pnpm or yarn if we get a lot bigger</li> <li>Vite for building, serving, and acting as an API proxy to our Java backend</li> <li>React for our UI framework</li> </ul> </li> <li>Material UI (mui)<ul> <li>Easy-to-use, well documented, and plenty of support available</li> </ul> </li> </ul> <p>This should provide a solid base foundation. I followed general scaffolding guidelines and utilized CoPilot to help generate the foundation. </p>"},{"location":"06-yak-shaving-redux/#blog-articles","title":"Blog Articles","text":"<p>I've been writing these Markdown documents, but so far, haven't made efforts to share them. To that end, we're going to create some GitHub Actions scripts that will publish to our GitHub Pages. We'll use the same Material theme, and utilize mkdocs to convert our markdown to a static html site. </p> <p>You can see this result at https://dustinbarnes.github.io/connect-four-demo (hopefully where you're reading this!).</p>"}]}